use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, debug, error, warn};
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

use crate::error::{AppResult, ResearchError};
use super::OutputFormat;

/// Output template for formatting
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputTemplate {
    pub id: String,
    pub name: String,
    pub content: String,
    pub format: OutputFormat,
    pub variables: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Template variable definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateVariable {
    pub name: String,
    pub description: String,
    pub default_value: Option<String>,
    pub required: bool,
    pub variable_type: VariableType,
}

/// Types of template variables
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VariableType {
    Text,
    Number,
    Boolean,
    Date,
    List,
    Object,
}

/// Template manager for handling output templates
pub struct TemplateManager {
    templates: Arc<RwLock<HashMap<String, OutputTemplate>>>,
    default_templates: HashMap<OutputFormat, OutputTemplate>,
}

impl TemplateManager {
    /// Create a new template manager
    pub async fn new() -> AppResult<Self> {
        info!("Initializing template manager...");

        let templates = Arc::new(RwLock::new(HashMap::new()));
        let default_templates = Self::create_default_templates();

        let manager = Self {
            templates,
            default_templates,
        };

        // Load default templates
        manager.load_default_templates().await?;

        info!("Template manager initialized successfully");
        Ok(manager)
    }

    /// Create default templates for each format
    fn create_default_templates() -> HashMap<OutputFormat, OutputTemplate> {
        let mut templates = HashMap::new();

        // Markdown template
        let markdown_template = OutputTemplate {
            id: "default_markdown".to_string(),
            name: "Default Markdown Report".to_string(),
            content: r#"# {{workflow_name}}

**Research Query:** {{workflow_query}}
**Status:** {{workflow_status}}
**Generated:** {{created_at}}

## Executive Summary

{{summary}}

## Key Findings

{{#each key_findings}}
- {{this}}
{{/each}}

## Detailed Analysis

{{detailed_analysis}}

## Sources

{{#each sources}}
- [{{title}}]({{url}})
{{/each}}

## Methodology

This research was conducted using automated research workflows with the following steps:

{{#each steps}}
### Step {{@index}}: {{step_type}}
**Status:** {{status}}
{{#if result}}
**Result:** {{result}}
{{/if}}
{{#if error}}
**Error:** {{error}}
{{/if}}
{{/each}}

---
*Generated by Research Engine on {{timestamp}}*"#.to_string(),
            format: OutputFormat::Markdown,
            variables: HashMap::from([
                ("workflow_name".to_string(), "Research workflow name".to_string()),
                ("workflow_query".to_string(), "Research query".to_string()),
                ("workflow_status".to_string(), "Workflow status".to_string()),
                ("created_at".to_string(), "Creation timestamp".to_string()),
                ("summary".to_string(), "Research summary".to_string()),
                ("key_findings".to_string(), "List of key findings".to_string()),
                ("detailed_analysis".to_string(), "Detailed analysis".to_string()),
                ("sources".to_string(), "List of sources".to_string()),
                ("steps".to_string(), "Workflow steps".to_string()),
                ("timestamp".to_string(), "Generation timestamp".to_string()),
            ]),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        // HTML template
        let html_template = OutputTemplate {
            id: "default_html".to_string(),
            name: "Default HTML Report".to_string(),
            content: r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{workflow_name}} - Research Report</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .summary { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .findings { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .step { margin: 10px 0; padding: 10px; border-left: 4px solid #007acc; background: #f9f9f9; }
        .footer { text-align: center; color: #666; margin-top: 40px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{workflow_name}}</h1>
        <p><strong>Query:</strong> {{workflow_query}}</p>
        <p><strong>Status:</strong> {{workflow_status}}</p>
        <p><strong>Generated:</strong> {{created_at}}</p>
    </div>

    <div class="summary">
        <h2>Executive Summary</h2>
        <p>{{summary}}</p>
    </div>

    <div class="findings">
        <h2>Key Findings</h2>
        <ul>
        {{#each key_findings}}
            <li>{{this}}</li>
        {{/each}}
        </ul>
    </div>

    <h2>Detailed Analysis</h2>
    <p>{{detailed_analysis}}</p>

    <h2>Sources</h2>
    <ol>
    {{#each sources}}
        <li><a href="{{url}}" target="_blank">{{title}}</a></li>
    {{/each}}
    </ol>

    <h2>Research Methodology</h2>
    {{#each steps}}
    <div class="step">
        <h3>Step {{@index}}: {{step_type}}</h3>
        <p><strong>Status:</strong> {{status}}</p>
        {{#if result}}<p><strong>Result:</strong> {{result}}</p>{{/if}}
        {{#if error}}<p><strong>Error:</strong> {{error}}</p>{{/if}}
    </div>
    {{/each}}

    <div class="footer">
        Generated by Research Engine on {{timestamp}}
    </div>
</body>
</html>"#.to_string(),
            format: OutputFormat::HTML,
            variables: HashMap::from([
                ("workflow_name".to_string(), "Research workflow name".to_string()),
                ("workflow_query".to_string(), "Research query".to_string()),
                ("workflow_status".to_string(), "Workflow status".to_string()),
                ("created_at".to_string(), "Creation timestamp".to_string()),
                ("summary".to_string(), "Research summary".to_string()),
                ("key_findings".to_string(), "List of key findings".to_string()),
                ("detailed_analysis".to_string(), "Detailed analysis".to_string()),
                ("sources".to_string(), "List of sources".to_string()),
                ("steps".to_string(), "Workflow steps".to_string()),
                ("timestamp".to_string(), "Generation timestamp".to_string()),
            ]),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        // JSON template
        let json_template = OutputTemplate {
            id: "default_json".to_string(),
            name: "Default JSON Report".to_string(),
            content: r#"{
  "report": {
    "metadata": {
      "workflow_name": "{{workflow_name}}",
      "query": "{{workflow_query}}",
      "status": "{{workflow_status}}",
      "generated_at": "{{created_at}}",
      "generator": "Research Engine"
    },
    "summary": "{{summary}}",
    "key_findings": [
      {{#each key_findings}}
      "{{this}}"{{#unless @last}},{{/unless}}
      {{/each}}
    ],
    "detailed_analysis": "{{detailed_analysis}}",
    "sources": [
      {{#each sources}}
      {
        "title": "{{title}}",
        "url": "{{url}}"
      }{{#unless @last}},{{/unless}}
      {{/each}}
    ],
    "methodology": {
      "steps": [
        {{#each steps}}
        {
          "step_number": {{@index}},
          "type": "{{step_type}}",
          "status": "{{status}}",
          "result": "{{result}}",
          "error": "{{error}}"
        }{{#unless @last}},{{/unless}}
        {{/each}}
      ]
    }
  }
}"#.to_string(),
            format: OutputFormat::JSON,
            variables: HashMap::from([
                ("workflow_name".to_string(), "Research workflow name".to_string()),
                ("workflow_query".to_string(), "Research query".to_string()),
                ("workflow_status".to_string(), "Workflow status".to_string()),
                ("created_at".to_string(), "Creation timestamp".to_string()),
                ("summary".to_string(), "Research summary".to_string()),
                ("key_findings".to_string(), "List of key findings".to_string()),
                ("detailed_analysis".to_string(), "Detailed analysis".to_string()),
                ("sources".to_string(), "List of sources".to_string()),
                ("steps".to_string(), "Workflow steps".to_string()),
            ]),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        templates.insert(OutputFormat::Markdown, markdown_template);
        templates.insert(OutputFormat::HTML, html_template);
        templates.insert(OutputFormat::JSON, json_template);

        templates
    }

    /// Load default templates into the manager
    async fn load_default_templates(&self) -> AppResult<()> {
        let mut templates = self.templates.write().await;
        
        for (_, template) in &self.default_templates {
            templates.insert(template.id.clone(), template.clone());
        }

        info!("Loaded {} default templates", self.default_templates.len());
        Ok(())
    }

    /// Get a template by ID
    pub async fn get_template(&self, template_id: &str) -> AppResult<OutputTemplate> {
        let templates = self.templates.read().await;
        
        templates.get(template_id)
            .cloned()
            .ok_or_else(|| ResearchError::not_found(format!("Template not found: {}", template_id)).into())
    }

    /// Get all templates
    pub async fn get_all_templates(&self) -> AppResult<Vec<OutputTemplate>> {
        let templates = self.templates.read().await;
        Ok(templates.values().cloned().collect())
    }

    /// Get templates by format
    pub async fn get_templates_by_format(&self, format: OutputFormat) -> AppResult<Vec<OutputTemplate>> {
        let templates = self.templates.read().await;
        Ok(templates.values()
            .filter(|t| t.format == format)
            .cloned()
            .collect())
    }

    /// Add a new template
    pub async fn add_template(&self, template: OutputTemplate) -> AppResult<()> {
        let mut templates = self.templates.write().await;
        templates.insert(template.id.clone(), template);
        Ok(())
    }

    /// Update an existing template
    pub async fn update_template(&self, template_id: &str, updated_template: OutputTemplate) -> AppResult<()> {
        let mut templates = self.templates.write().await;
        
        if templates.contains_key(template_id) {
            templates.insert(template_id.to_string(), updated_template);
            Ok(())
        } else {
            Err(ResearchError::not_found(format!("Template not found: {}", template_id)).into())
        }
    }

    /// Delete a template
    pub async fn delete_template(&self, template_id: &str) -> AppResult<()> {
        let mut templates = self.templates.write().await;
        
        if templates.remove(template_id).is_some() {
            Ok(())
        } else {
            Err(ResearchError::not_found(format!("Template not found: {}", template_id)).into())
        }
    }

    /// Get default template for a format
    pub fn get_default_template(&self, format: OutputFormat) -> Option<&OutputTemplate> {
        self.default_templates.get(&format)
    }
}
