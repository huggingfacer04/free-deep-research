use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

/// Knowledge node model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KnowledgeNode {
    pub id: Uuid,
    pub node_type: NodeType,
    pub name: String,
    pub description: Option<String>,
    pub properties: HashMap<String, serde_json::Value>,
    pub embedding_vector: Option<Vec<f32>>,
    pub confidence_score: f64,
    pub source_type: SourceType,
    pub source_id: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Node type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum NodeType {
    Concept,
    Entity,
    Research,
    Methodology,
    Person,
    Organization,
    Publication,
    Dataset,
    Technology,
    Event,
    Location,
    Topic,
}

/// Source type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SourceType {
    ResearchWorkflow,
    ExternalSource,
    UserInput,
    AutoGenerated,
    ImportedData,
    ApiIngestion,
}

/// Knowledge relationship model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KnowledgeRelationship {
    pub id: Uuid,
    pub source_node_id: Uuid,
    pub target_node_id: Uuid,
    pub relationship_type: RelationshipType,
    pub relationship_strength: f64, // 0.0 to 1.0
    pub relationship_properties: HashMap<String, serde_json::Value>,
    pub evidence_sources: Vec<EvidenceSource>,
    pub confidence_score: f64,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Relationship type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum RelationshipType {
    RelatedTo,
    PartOf,
    Causes,
    Enables,
    Influences,
    DependsOn,
    SimilarTo,
    OppositeOf,
    InstanceOf,
    SubclassOf,
    AuthoredBy,
    CitedBy,
    UsedIn,
    BasedOn,
    Extends,
    Implements,
    Contains,
    LocatedIn,
    OccurredAt,
    Precedes,
    Follows,
}

/// Evidence source
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvidenceSource {
    pub source_id: String,
    pub source_type: String,
    pub source_url: Option<String>,
    pub relevance_score: f64,
    pub extraction_method: String,
    pub timestamp: DateTime<Utc>,
}

/// Data source model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataSource {
    pub id: Uuid,
    pub source_name: String,
    pub source_type: DataSourceType,
    pub source_url: Option<String>,
    pub access_method: AccessMethod,
    pub credibility_score: f64,
    pub update_frequency: UpdateFrequency,
    pub last_accessed: Option<DateTime<Utc>>,
    pub data_format: DataFormat,
    pub access_credentials_id: Option<String>,
    pub status: DataSourceStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Data source type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DataSourceType {
    Academic,
    Web,
    Database,
    Api,
    File,
    Stream,
    Repository,
    Wiki,
    News,
    Social,
}

/// Access method
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AccessMethod {
    Api,
    Scraping,
    Manual,
    Rss,
    Webhook,
    FileUpload,
    DatabaseQuery,
}

/// Update frequency
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum UpdateFrequency {
    RealTime,
    Hourly,
    Daily,
    Weekly,
    Monthly,
    Quarterly,
    Yearly,
    OnDemand,
    Static,
}

/// Data format
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DataFormat {
    Json,
    Xml,
    Csv,
    Pdf,
    Html,
    Text,
    Binary,
    Rdf,
    Turtle,
    JsonLd,
}

/// Data source status
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DataSourceStatus {
    Active,
    Inactive,
    Error,
    Maintenance,
    Deprecated,
    Unauthorized,
}

/// Graph visualization model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphVisualization {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub graph_query: GraphQuery,
    pub layout_config: LayoutConfiguration,
    pub visual_config: VisualConfiguration,
    pub node_filters: Vec<NodeFilter>,
    pub relationship_filters: Vec<RelationshipFilter>,
    pub created_by: Option<String>,
    pub is_public: bool,
    pub usage_count: u32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Graph query
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphQuery {
    pub query_type: QueryType,
    pub query_string: String,
    pub parameters: HashMap<String, serde_json::Value>,
    pub max_nodes: Option<u32>,
    pub max_relationships: Option<u32>,
    pub depth_limit: Option<u32>,
}

/// Query type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum QueryType {
    Cypher,
    Sparql,
    GraphQL,
    Custom,
    PathFinding,
    Neighborhood,
    Similarity,
}

/// Layout configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayoutConfiguration {
    pub layout_algorithm: LayoutAlgorithm,
    pub parameters: HashMap<String, f64>,
    pub node_spacing: f64,
    pub edge_length: f64,
    pub iterations: u32,
    pub stabilization_enabled: bool,
}

/// Layout algorithm
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LayoutAlgorithm {
    ForceDirected,
    Hierarchical,
    Circular,
    Grid,
    Random,
    Fruchterman,
    Kamada,
    SpringEmbedder,
}

/// Visual configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VisualConfiguration {
    pub node_styles: HashMap<NodeType, NodeStyle>,
    pub edge_styles: HashMap<RelationshipType, EdgeStyle>,
    pub color_scheme: ColorScheme,
    pub font_settings: FontSettings,
    pub interaction_settings: InteractionSettings,
}

/// Node style
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeStyle {
    pub shape: NodeShape,
    pub size: f64,
    pub color: String,
    pub border_color: String,
    pub border_width: f64,
    pub label_visible: bool,
    pub icon: Option<String>,
}

/// Node shape
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum NodeShape {
    Circle,
    Square,
    Triangle,
    Diamond,
    Star,
    Hexagon,
    Ellipse,
    Rectangle,
}

/// Edge style
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EdgeStyle {
    pub line_type: LineType,
    pub width: f64,
    pub color: String,
    pub arrow_type: ArrowType,
    pub label_visible: bool,
    pub curvature: f64,
}

/// Line type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LineType {
    Solid,
    Dashed,
    Dotted,
    DashDot,
}

/// Arrow type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ArrowType {
    None,
    Arrow,
    Circle,
    Square,
    Diamond,
    Triangle,
}

/// Color scheme
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColorScheme {
    pub scheme_name: String,
    pub primary_colors: Vec<String>,
    pub background_color: String,
    pub text_color: String,
    pub highlight_color: String,
}

/// Font settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FontSettings {
    pub font_family: String,
    pub font_size: u32,
    pub font_weight: FontWeight,
    pub font_style: FontStyle,
}

/// Font weight
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FontWeight {
    Normal,
    Bold,
    Light,
    ExtraBold,
}

/// Font style
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FontStyle {
    Normal,
    Italic,
    Oblique,
}

/// Interaction settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InteractionSettings {
    pub zoom_enabled: bool,
    pub pan_enabled: bool,
    pub selection_enabled: bool,
    pub hover_effects: bool,
    pub click_actions: Vec<ClickAction>,
    pub keyboard_shortcuts: HashMap<String, String>,
}

/// Click action
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClickAction {
    pub trigger: ClickTrigger,
    pub action_type: ActionType,
    pub parameters: HashMap<String, serde_json::Value>,
}

/// Click trigger
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ClickTrigger {
    SingleClick,
    DoubleClick,
    RightClick,
    MiddleClick,
}

/// Action type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ActionType {
    ShowDetails,
    ExpandNeighbors,
    HighlightPath,
    FilterByType,
    OpenUrl,
    RunQuery,
    Custom,
}

/// Node filter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeFilter {
    pub filter_name: String,
    pub node_types: Vec<NodeType>,
    pub property_filters: Vec<PropertyFilter>,
    pub confidence_threshold: Option<f64>,
    pub date_range: Option<DateRange>,
}

/// Relationship filter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelationshipFilter {
    pub filter_name: String,
    pub relationship_types: Vec<RelationshipType>,
    pub strength_threshold: Option<f64>,
    pub property_filters: Vec<PropertyFilter>,
    pub bidirectional: bool,
}

/// Property filter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PropertyFilter {
    pub property_name: String,
    pub operator: FilterOperator,
    pub value: serde_json::Value,
    pub case_sensitive: bool,
}

/// Filter operator
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FilterOperator {
    Equals,
    NotEquals,
    Contains,
    NotContains,
    StartsWith,
    EndsWith,
    GreaterThan,
    LessThan,
    GreaterThanOrEqual,
    LessThanOrEqual,
    In,
    NotIn,
    Regex,
}

/// Date range
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DateRange {
    pub start_date: DateTime<Utc>,
    pub end_date: DateTime<Utc>,
}

/// Knowledge graph statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KnowledgeGraphStatistics {
    pub total_nodes: u64,
    pub total_relationships: u64,
    pub node_type_distribution: HashMap<NodeType, u64>,
    pub relationship_type_distribution: HashMap<RelationshipType, u64>,
    pub average_node_degree: f64,
    pub graph_density: f64,
    pub connected_components: u32,
    pub largest_component_size: u64,
    pub average_path_length: f64,
    pub clustering_coefficient: f64,
    pub last_updated: DateTime<Utc>,
}

/// Graph traversal request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphTraversalRequest {
    pub start_node_id: Uuid,
    pub traversal_type: TraversalType,
    pub max_depth: u32,
    pub relationship_types: Option<Vec<RelationshipType>>,
    pub node_types: Option<Vec<NodeType>>,
    pub filters: Vec<TraversalFilter>,
    pub return_paths: bool,
}

/// Traversal type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TraversalType {
    BreadthFirst,
    DepthFirst,
    ShortestPath,
    AllPaths,
    RandomWalk,
    PageRank,
}

/// Traversal filter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraversalFilter {
    pub filter_type: TraversalFilterType,
    pub condition: String,
    pub value: serde_json::Value,
}

/// Traversal filter type
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TraversalFilterType {
    NodeProperty,
    RelationshipProperty,
    NodeType,
    RelationshipType,
    ConfidenceScore,
    RelationshipStrength,
}

/// Graph traversal result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphTraversalResult {
    pub nodes: Vec<KnowledgeNode>,
    pub relationships: Vec<KnowledgeRelationship>,
    pub paths: Option<Vec<GraphPath>>,
    pub statistics: TraversalStatistics,
}

/// Graph path
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphPath {
    pub path_id: Uuid,
    pub nodes: Vec<Uuid>,
    pub relationships: Vec<Uuid>,
    pub path_length: u32,
    pub path_weight: f64,
}

/// Traversal statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraversalStatistics {
    pub nodes_visited: u32,
    pub relationships_traversed: u32,
    pub execution_time_ms: u32,
    pub memory_used_mb: f64,
    pub paths_found: u32,
}
